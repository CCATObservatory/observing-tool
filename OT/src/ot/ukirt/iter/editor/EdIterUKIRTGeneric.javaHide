// Copyright 1997 Association for Universities for Research in Astronomy, Inc.,
// Observatory Control System, Gemini Telescopes Project.
// See the file COPYRIGHT for complete details.
//
// $Id$
//
package ot.ukirt.iter.editor;

import gemini.gui.CellSelectTableWatcher;
import gemini.gui.CellSelectTableWidget;
import gemini.gui.PresentationWindow;

import gemini.gui.ListBoxWidgetExt;
import gemini.gui.ListBoxWidgetWatcher;
import gemini.gui.TextBoxWidgetExt;
import gemini.gui.TextBoxWidgetWatcher;

import gemini.sp.SpAvTable;
import gemini.sp.SpItem;
import gemini.sp.iter.IterConfigItem;
import gemini.sp.iter.SpIterConfigBase;

import org.freebongo.gui.GroupWidget;
import org.freebongo.gui.StaticTextWidget;
import org.freebongo.gui.TableColumn;
import org.freebongo.gui.Widget;

import java.awt.Event;
import java.util.Hashtable;
import java.util.Vector;



//
// Helper class for EdIterGenericConfig.  It is the base class for editing
// various attribute types (currently "list of choices" and "text box").
// The ICValueEditor is concerned with displaying the control needed to
// edit a particular attribute, as described by a
// gemini.sp.iter.IterConfigItem.  When the user changes the value in the
// editor, the EdIterGenericConfig instance is informed of the new value.
// Each ICValueEditor subclass appears in its own GroupWidget.
//
abstract class ICValueEditor
{
   protected EdIterUKIRTGeneric  _ci;
   protected GroupWidget         _container;
   protected StaticTextWidget    _title;

ICValueEditor(EdIterUKIRTGeneric ci, GroupWidget gw, StaticTextWidget title)
{
   _ci        = ci;
   _container = gw;
   _title     = title;
}
  
// Hide the GroupWidget that contains the editor's widgets.
void hide()
{
   _container.hide();
}

// Show the GroupWidget that contains the editor's widgets.
void show()
{
   _container.show();
   _container.toFront();
}

// Update the editor's widgets to reflect the given IterConfigItem.
abstract void editValue(IterConfigItem configItem, String curValue);

// Update the editor's widgets to show no value.
abstract void clear();

}


//
// An ICValueEditor for ListBoxes.
//
class ICListBoxValueEditor extends ICValueEditor
                         implements ListBoxWidgetWatcher
{
   ListBoxWidgetExt _choicesLBW;
   IterConfigItem   _lastICI;

ICListBoxValueEditor(EdIterUKIRTGeneric ci,
                   GroupWidget gw, StaticTextWidget stw, ListBoxWidgetExt lbw)
{
   super(ci, gw, stw);
   _choicesLBW = lbw;
   _choicesLBW.addWatcher(this);
}

// Show the list of choices defined in the IterConfigItem, and select the
// curValue.
void
editValue(IterConfigItem configItem, String curValue)
{
   _title.setText(configItem.title + " Choices");

   _choicesLBW.deleteWatcher(this);

   if (configItem != _lastICI) {
      // Have to avoid resetting the choices unless the item has changed.
      // There's a bug in Bongo1.1 that breaks the application if you remove
      // the item that caused an event in the event callback ...

      _choicesLBW.setChoices(configItem.choices);
      _lastICI = configItem;
   }

   if ((curValue == null) || curValue.equals("")) {
      _choicesLBW.setValue(-1);
   } else {
      _choicesLBW.setValue(curValue);
      _choicesLBW.focusAtSelectedItem();
   }
   _choicesLBW.addWatcher(this);
}

void
clear()
{
   _title.setText("Nothing Selected");
   _choicesLBW.deleteWatcher(this);
   _choicesLBW.clear();
   _choicesLBW.addWatcher(this);
   _lastICI = null;
}

// Called when the user selects an option from the list box.  The
// EdIterGenericConfig instance is informed of the new value.
public void
listBoxSelect(ListBoxWidgetExt w, int index, String val)
{
   // There is a new value for the current attribute, but the user
   // may not be finished editing.
   _ci.cellValueChanged(val, false);
}
 
// Called when the user double-clicks an option from the list box.
// The EdIterGenericConfig instance is informed of the new value.
public void
listBoxAction(ListBoxWidgetExt w, int index, String val)
{
   // There is a new value for the current attribute, and the user
   // is finished editing.
   _ci.cellValueChanged(val, true);
}

}


//
// An ICValueEditor for TextBoxes.
//
class ICTextBoxValueEditor extends ICValueEditor
                         implements TextBoxWidgetWatcher
{
   TextBoxWidgetExt _textBox;

ICTextBoxValueEditor(EdIterUKIRTGeneric ci,
                    GroupWidget gw, StaticTextWidget stw, TextBoxWidgetExt tbw)
{
   super(ci, gw, stw);
   _textBox = tbw;
   _textBox.addWatcher(this);
}

//
// Put the curValue in the text box.
//
void
editValue(IterConfigItem configItem, String curValue)
{
   _title.setText("Enter " + configItem.title + ":");
   _textBox.setText(curValue);
}

void
clear()
{
   _title.setText("Nothing Selected");
   _textBox.setText("");
}

// Called when the user types a key in the text box.  The
// EdIterGenericConfig instance is informed of the new value.
public void
textBoxKeyPress(TextBoxWidgetExt tbw)
{
   _ci.cellValueChanged( tbw.getText(), false );
}
 
// Called when the user types a return key in the text box.  The
// EdIterGenericConfig instance is informed of the new value.
public void
textBoxAction(TextBoxWidgetExt tbw)
{
   _ci.cellValueChanged( tbw.getText(), true );
}

}


public class EdIterUKIRTGeneric extends ot.editor.EdIterGenericConfig
{
   // The iteration table widget.
   private CellSelectTableWidget _iterTab;

   // Maps attribute names to IterConfigItems.
   private Hashtable             _iterItems;

   // The array of available items.
   private IterConfigItem[]      _iciA;

   // A ref to either _listBoxVE or _textBoxVE, depending upon the type of
   // attribute represented by the selected cell.
   private ICValueEditor        _valueEditor;
   private ICListBoxValueEditor _listBoxVE;
   private ICTextBoxValueEditor _textBoxVE;

   // The list box that contains the available items.
   private ListBoxWidgetExt     _itemsLBW;

public EdIterUKIRTGeneric()
{
  super();
}

/**
 * Perform any required one-time initialization.- overrides one in
 * EdIterGenericConfig: currently does exactly the same, but this will need
 * to change...
 */
protected void
_init()
{
   // Watch for selection of cells in the iterator table.
   _iterTab   = (CellSelectTableWidget) _pres.getWidget("iterStepsTable");
   _iterTab.addWatcher(this);

   // Watch for selection of available items.
   _itemsLBW = (ListBoxWidgetExt) _pres.getWidget("availableItems");
   _itemsLBW.addWatcher(this);

   GroupWidget gw;
   StaticTextWidget stw;

   // Initialize the ListBox value editor
   gw  = (GroupWidget) _pres.getWidget("listBoxGroup");
   stw = (StaticTextWidget) gw.getWidget("listBoxTitle");
   ListBoxWidgetExt lbw;
   lbw = (ListBoxWidgetExt) gw.getWidget("availableChoices");
   _listBoxVE = new ICListBoxValueEditor(this, gw, stw, lbw);

   // Initialize the TextBox value editor
   gw = (GroupWidget) _pres.getWidget("textBoxGroup");
   stw = (StaticTextWidget) gw.getWidget("textBoxTitle");
   TextBoxWidgetExt tbw;
   tbw = (TextBoxWidgetExt) gw.getWidget("textBox");
   _textBoxVE = new ICTextBoxValueEditor(this, gw, stw, tbw);

   _valueEditor = _listBoxVE;
   _listBoxVE.show();
   _textBoxVE.hide();

   _iterItems = new Hashtable();

}

/**
 * Override setup() to initialize the array of available items and show
 * the name of the SpItem in the OtItemEditorWindow banner title.
 */
public void
setup(SpItem spItem)
{
   if (!(spItem instanceof SpIterConfigBase)) {
      // Oops, this is a bug so throw an exception
      throw new RuntimeException("Tried to setup an configuration iterator with the wrong kind of SpItem!");
   }

   // Initialize the array of available items.
   _iciA = ((SpIterConfigBase) spItem).getAvailableItems();
      
   // Show the name of the SpItem in the main window, overriding the value
   // of _title.
   String name = ((SpIterConfigBase) spItem).getItemName();
   setEditorWindowTitle(name + " Configuration Iterator");

   super.setup(spItem);
}

/**
 * Update the widgets to display the values of the attributes in the
 * current SpItem.
 */
protected void
_updateWidgets()
{
   // Clear everything
   _iterItems.clear();
   _iterTab.removeAllRows();
   _iterTab.removeAllColumns();

   _listBoxVE.show();
   _textBoxVE.hide();

   _valueEditor = _listBoxVE;
   _valueEditor.clear();

   SpIterConfigBase icb = (SpIterConfigBase) _spItem;

   //
   // Add all the items from the table.
   //

   // Each element in the array is the name of an attribute being iterated
   // over.
   Vector v = icb.getConfigAttribs();

   if ((v == null) || (v.size() == 0)) {
      // Nothing is being iterated over
      _initAvailableItems();
      _updateTableInfo();
      return;
   }

   // For each attribute, add a column in the table, and enter each of
   // the attribute's steps in subsequent table rows.
   int index = 0;
   for (int i=0; i<v.size(); ++i) {
      String attrib = (String) v.elementAt(i);

      if (!attrib.startsWith("instAper")) {
	// Add a column for the item
	IterConfigItem ici = _getIterConfigItem(attrib);
	if (ici == null) {
	  continue;
	}
	_addConfigItem(ici);
	
	// Make sure there are enough rows to hold the item's values.
	Vector vals = icb.getConfigSteps(attrib);
	for (int j=_iterTab.getRowCount(); j<vals.size(); ++j) {
	  _iterTab.addRow();
	}
	
	for (int j=0; j<vals.size(); ++j) {
	  _iterTab.setCell(vals.elementAt(j), index, j);
	}
	++index;
      }
   }

   // Select the upper left hand cell, causing its editor to be displayed.
   if ((_iterTab.getColumnCount() > 0) && (_iterTab.getRowCount() > 0)) {
      _iterTab.selectCell(0, 0);
   }

   _initAvailableItems();
   _updateTableInfo();
}

//
// Update table info text box that shows the number of items and steps
// in the table.
//
private void
_updateTableInfo()
{
   StaticTextWidget stw = (StaticTextWidget) _pres.getWidget("tableInfo");
   int items = _iterTab.getColumnCount();
   int steps = _iterTab.getRowCount();

   String message = "(" + items;
   if (items == 1) {
      message += " Item, ";
   } else {
      message += " Items, ";
   }
   message += steps;
   if (steps == 1) {
      message += " Step)";
   } else {
      message += " Steps)";
   }

   stw.setText(message);
}

//
// Get the IterConfigItem, given the attribute name associated with it.
//
private IterConfigItem
_getIterConfigItem(String attrib)
{
   // Go through the array of available IterConfigItems, and return the one
   // whose attribute name matches the attrib parameter.

   for (int i=0; i<_iciA.length; ++i) {
      if (_iciA[i].attribute.equals(attrib)) {
         return _iciA[i];
      }
   }
   return null;
}

//
// Get the IterConfigItem associated with the selected column.  The
// IterConfigItem is used to fill in the editor for the attribute.
//
private IterConfigItem
_getCurIterConfigItem()
{
   // Get the column index of the selected cell.
   int[] coord  = _iterTab.getSelectedCoordinates();
   int colIndex = coord[0];
   if (colIndex == -1) {
      return null;
   }

   // Figure out the title of the column of the selected cell.
   TableColumn tc = _iterTab.getColumn(colIndex);
   String   title = tc.label;

   // Go trhough the array of available IterConfigItems, and return the one
   // whose title matches the table column's title.
   for (int i=0; i<_iciA.length; ++i) {
      if (_iciA[i].title.equals(title)) {
         return _iciA[i];
      }
   }
   return null;
}

//
// Given a column index, get the IterConfigItem associated with it.
//
private IterConfigItem
_getConfigItem(int colIndex)
{
   TableColumn tc = _iterTab.getColumn(colIndex);
   return (IterConfigItem) _iterItems.get(tc.label);
}

//
// Get the column index associated with the given IterConfigItem.
//
private int
_getColIndex(IterConfigItem ici)
{
   // Find the index of the column that should be deleted
   int col = -1;
   for (int i=0; i<_iterTab.getColumnCount(); ++i) {
      TableColumn tc = _iterTab.getColumn(i);
      if (tc.label.equals(ici.title)) {
         col = i;
         break;
      }
   }

   return col;
}

/**
 * Select the cell on the current row in the given column.
 */
public void
selectColumnCell(int colIndex)
{
   int[] coord  = _iterTab.getSelectedCoordinates();
   int rowIndex = coord[1];
   _iterTab.selectCell(colIndex, rowIndex);
   _iterTab.focusAtCell(colIndex, rowIndex);
}


//
// Add a configuration item.  Does the work for the public addConfigItem
// method.  Also called in _updateWidgets.
//
private void
_addConfigItem(IterConfigItem ici)
{
   _iterTab.addColumn(ici.title, 105);
   _iterItems.put(ici.title, ici);
}

/**
 * Add a new attribute to iterate over.
 */
public void
addConfigItem(IterConfigItem ici)
{
   String dbg = getClass().getName();

   _addConfigItem(ici);

   ((SpIterConfigBase) _spItem).addConfigItem(ici, _iterTab.getRowCount());

   // If there are no steps yet, add the first one automatically, else
   // select the cell on the current row that is in the newly added column.
   if (_iterTab.getRowCount() == 0) {
       // Don't think this is needed if I'm setting defaults in addConfigItem
       //      addStep();
   } else {
      selectColumnCell(_iterTab.getColumnCount() - 1);
   }
   _updateWidgets();
   selectColumnCell(_iterTab.getColumnCount() - 1);
}


/**
 * Remove an attribute from the set being iterated over.
 */
public void
deleteConfigItem(IterConfigItem ici)
{
   if (_iterTab.getColumnCount() == 0) return;

   // Find the index of the column that should be deleted
   int deleteCol = _getColIndex(ici);
   if (deleteCol == -1) return;

   _deleteColumn(ici, deleteCol);
}


/**
 * Delete the column of the currently selected cell from the table.  This
 * will result in removing the associated attribute from the set of
 * attributes being iterated over.
 */
public void
deleteSelectedColumn()
{
   IterConfigItem ici = _getCurIterConfigItem();
   int            col = _getColIndex(ici);
   _deleteColumn(ici, col);
}

//
// Delete the given attribute at the given column index.
//
private void
_deleteColumn(IterConfigItem ici, int deleteCol)
{
   if (_iterTab.getColumnCount() == 0) {
      return;
   }

   // Remember which cell was selected.
   int[] coord  = _iterTab.getSelectedCoordinates();
   int colIndex = coord[0];
   int rowIndex = coord[1];

   // Remove the item from the hashtable and from the table widget
   _iterItems.remove(ici.title);
   _iterTab.removeColumnAt(deleteCol);

   // Make sure the colIndex is still valid
   if (_iterTab.getColumnCount() <= colIndex) {
      colIndex = _iterTab.getColumnCount() - 1;
   }

   // Reselect the old col,row if there's anything left in the table,
   // otherwise, remove all the rows and all the available choices.
   if (colIndex >= 0) {
      _iterTab.selectCell(colIndex, rowIndex);
      _iterTab.focusAtRow(rowIndex);
   } else {
      _iterTab.removeAllRows();
      _valueEditor.clear();
   }

   // Remove the attribute from the table.
   ((SpIterConfigBase) _spItem).deleteConfigItem(ici.attribute);

   // In Bongo1.0, used to just reinit the list of available items, removing
   // the just added value.  That no longer works, so now just select nothing.
   //_initAvailableItems();
   _unselectAvailableItems();

   _updateTableInfo();
}


/**
 * Add an iteration step.
 */
public void
addStep()
{
   if (_iterTab.getColumnCount() == 0) {
      return;
   }

   // Figure out the coordinates of the currently selected cell, if any
   int[] coord  = _iterTab.getSelectedCoordinates();
   int colIndex = coord[0];
   int rowIndex = coord[1];
   if (colIndex == -1) {
      colIndex = 0;
   }

   _iterTab.absInsertRowAt(null, ++rowIndex);

   // Insert a blank element into all the iterator attributes.
   ((SpIterConfigBase) _spItem).insertConfigStep(rowIndex);

   _updateWidgets ();

   // Select the cell in the current column, newly added row
   _iterTab.selectCell(colIndex, rowIndex);
   _iterTab.focusAtRow(rowIndex);

   //   _updateTableInfo();
}


/**
 * Delete an iteration step.
 */
public void
deleteStep()
{
   if ((_iterTab.getColumnCount() == 0) || (_iterTab.getRowCount() == 0)) {
      return;
   }

   int[] coord = _iterTab.getSelectedCoordinates();
   if ((coord[0] == -1) || (coord[1] == -1)) {
      return;
   }

   int rowIndex = coord[1];
   _iterTab.removeRowAt(rowIndex);

   // Delete the element from all the iterator attributes.
   ((SpIterConfigBase) _spItem).deleteConfigStep(rowIndex);

   // Select the next cell in the next step (or previous step if this was
   // the last element.)
   if (_iterTab.getRowCount() <= rowIndex) {
      rowIndex = _iterTab.getRowCount() - 1;
   }

   if (rowIndex >= 0) {
      _iterTab.selectCell(coord[0], rowIndex);
      _iterTab.focusAtRow(rowIndex);
      _updateTableInfo();
   } else {
      //_valueEditor.clear();
      addStep();  // Leave a blank step
   }
}

/**
 * Move the current step to be the first step.
 */
public void
stepToFirst()
{
   int[] coord = _iterTab.getSelectedCoordinates();
   if ((coord[0] == -1) || (coord[1] == -1)) {
      return;
   }

   int rowIndex = coord[1];
   _iterTab.absMoveToFirstRowAt(rowIndex);

   // Move the attribute elements in the avTable
   ((SpIterConfigBase) _spItem).configStepToFirst(rowIndex);

   // Select the cell that was just moved
   _iterTab.selectCell(coord[0], 0);
   _iterTab.focusAtRow(0);
}



/**
 * Move the current step up one.
 */
public void
decrementStep()
{
   int[] coord = _iterTab.getSelectedCoordinates();
   if ((coord[0] == -1) || (coord[1] == -1)) {
      return;
   }

   int rowIndex = coord[1];
   _iterTab.absDecrementRowAt(rowIndex);

   // Move the attribute elements in the avTable
   ((SpIterConfigBase) _spItem).configStepDecrement(rowIndex);

   // Select the cell that was just moved
   if (--rowIndex >= 0) {
      _iterTab.selectCell(coord[0], rowIndex);
      _iterTab.focusAtRow(rowIndex);
   }
}

/**
 * Move the current step down one.
 */
public void
incrementStep()
{
   int[] coord = _iterTab.getSelectedCoordinates();
   if ((coord[0] == -1) || (coord[1] == -1)) {
      return;
   }

   int rowIndex = coord[1];
   _iterTab.absIncrementRowAt(rowIndex);

   // Move the attribute elements in the avTable
   ((SpIterConfigBase) _spItem).configStepIncrement(rowIndex);

   // Select the cell that was just moved
   if (++rowIndex <= (_iterTab.getRowCount() - 1)) {
      _iterTab.selectCell(coord[0], rowIndex);
      _iterTab.focusAtRow(rowIndex);
   }
}

/**
 * Move the current step to the end.
 */
public void
stepToLast()
{
   int[] coord = _iterTab.getSelectedCoordinates();
   if ((coord[0] == -1) || (coord[1] == -1)) {
      return;
   }

   int rowIndex = coord[1];
   _iterTab.absMoveToLastRowAt(rowIndex);

   // Move the attribute elements in the avTable
   ((SpIterConfigBase) _spItem).configStepToLast(rowIndex);

   // Select the cell that was just moved
   rowIndex = _iterTab.getRowCount() - 1;
   _iterTab.selectCell(coord[0], rowIndex);
   _iterTab.focusAtRow(rowIndex);
}

//
// Change the _valueEditor reference to the given value editor.  The
// old value editor will be hidden, and the new one shown.
//
private void
_setEditor(ICValueEditor ve)
{
   if (_valueEditor == ve) {
      return;
   }

   if (_valueEditor != null) {
      _valueEditor.hide();
   }

   _valueEditor = ve;
   _valueEditor.show();
}

/**
 * Called when a table cell is selected.  The value editor is reconfigured
 * to display the appropriate editor for the attribute in the selected
 * cell.
 *
 * @see CellSelectTableWidget
 */
public void
cellSelected(CellSelectTableWidget w, int colIndex, int rowIndex)
{
   String cellValue = (String) w.getCell(colIndex, rowIndex);

   TableColumn tc = _iterTab.getColumn(colIndex);
   //System.out.println("Selected column: " + tc.label);

   IterConfigItem ici = (IterConfigItem) _iterItems.get(tc.label);

   if (ici.choices == null) {
      _setEditor(_textBoxVE);
   } else {
      _setEditor(_listBoxVE);
   }

   _valueEditor.editValue(ici, cellValue);
}

/**
 * Ignore cell actions.
 * @see CellSelectTableWidget
 */
public void
cellAction(CellSelectTableWidget w, int colIndex, int rowIndex)
{
   // Don't care ...
}

//
// Turn off the selection in the list box containing the available
// items.  (This method was needed to support the workaround for the
// bug in Bongo1.1 -- see the note in _initAvailableItems.
//
private void
_unselectAvailableItems()
{
   _itemsLBW.deleteWatcher(this);
   _itemsLBW.setValue(-1);
   _itemsLBW.addWatcher(this);
}

//
// Initialize the list box containing the available items.
//
private void
_initAvailableItems()
{
   Vector v = new Vector();

   for (int i=0; i<_iciA.length; ++i) {
      // In Bongo1.0, used to only add the items that weren't already in
      // the table.  Used to only show the items that weren't already in
      // the table.  But you can't dynamically remove an item in Bongo1.1
      // in the callback for its selection.  So now I just show everything
      // and never remove items from the list ...

      IterConfigItem ici = _iciA[i];
//      if (!isCurrentIterItem( ici.title )) {
      if (!ici.title.startsWith("InstAper")) 
	  v.addElement(ici.title);
//      }
   }

   _itemsLBW.deleteWatcher(this);
   _itemsLBW.setValue(-1);
   _itemsLBW.setChoices(v);
   _itemsLBW.addWatcher(this);
}

/**
 * Called when an item is selected from the list of available items.  The
 * corresponding attribute is added as a table column and the selection
 * is moved to the new column.
 *
 * @see ListBoxWidgetWatcher
 */
public void
listBoxSelect(ListBoxWidgetExt w, int index, String val)
{
   if (w != _itemsLBW) {
      // Something odd happened
      throw new RuntimeException("weird listBoxSelect error: " + w);
   }

   IterConfigItem ici = null;
   for (int i=0; i<_iciA.length; ++i) {
      if (val.equals(_iciA[i].title)) {
         ici = _iciA[i];
      }
   }
 
   if (ici == null) return;

   // Find the index of the column, if it is already in the table.  If not,
   // add it.  If so, select it.
   int colIndex = _getColIndex(ici);
   if (colIndex == -1) {
      addConfigItem(ici);
   } else {
      selectColumnCell(colIndex);
   }

   // In Bongo1.0, used to just reinit the list of available items, removing
   // the just added value.  That no longer works, so now just select nothing.
   //_initAvailableItems();
   _unselectAvailableItems();

   _updateTableInfo();
}
 
/**
 * Ignore list box actions.
 * @see ListBoxWidgetWatcher
 */
public void
listBoxAction(ListBoxWidgetExt w, int index, String val)
{
    // Don't care ...
}

/**
 * This method is called when the value of the selected step and attribute
 * is changed.
 */
public void
cellValueChanged(String newVal, boolean finishedEditing)
{
   // Get the selected cell's coordinates
   int[] coord = _iterTab.getSelectedCoordinates();
   if ((coord[0] == -1) || (coord[1] == -1)) {
      return;
   }
   int colIndex = coord[0];
   int rowIndex = coord[1];

   // Figure out the IterConfigItem that goes with the selected cell
   IterConfigItem ici = _getConfigItem(colIndex);
   if (ici == null) {
      throw new RuntimeException("couldn't find the IterConfigItem associated with column: " + colIndex);
   }

   // Set the value in the selected cell
   _iterTab.setSelectedCell(newVal);

   ((SpIterConfigBase) _spItem).setConfigStep(ici.attribute, newVal, rowIndex);

   ++rowIndex;

   if ((finishedEditing) && (rowIndex < _iterTab.getRowCount())) {
      // Move to the next cell down in the column
      _iterTab.selectCell(colIndex, rowIndex);
      _iterTab.focusAtCell(colIndex, rowIndex);
   }
}

//
// Handle action events on the buttons in the editor. 
//
private void
_widgetAction(Widget w, String name)
{
   // Delete the selected column
   if ("deleteTest".equals(name)) {
      deleteSelectedColumn(); return;
   }

   // Add a row (iter step) to the table
   if ("addStep".equals(name)) {
      addStep(); return;
   }

   // Delete a row (iter step) from the table
   if ("deleteStep".equals(name)) {
      deleteStep(); return;
   }

   // Move a row (iter step) to the end
   if ("top".equals(name)) {
      stepToFirst(); return;
   }

   // Move a row (iter step) up
   if ("up".equals(name)) {
      decrementStep(); return;
   }

   // Move a row (iter step) down
   if ("down".equals(name)) {
      incrementStep(); return;
   }

   // Move a row (iter step) to the end
   if ("bottom".equals(name)) {
      stepToLast(); return;
   }
}


/**
 * Override to handle button presses.
 */
public boolean
handleEvent(Event evt)
{
   if (! (evt.target instanceof Widget) ) {
      return super.handleEvent(evt);
   }

   Widget w    = (Widget) evt.target;
   String name = w.getName();

   if (evt.id == Event.ACTION_EVENT) {
      _widgetAction(w, name);
      return true;
   }

   return super.handleEvent(evt);
}

}
